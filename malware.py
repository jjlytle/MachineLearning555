#Jeffrey Lytle's Version 1.0

import warnings
import pandas as pd
import pickle
import dill
import numpy as np
import os

os.environ['KMP_DUPLICATE_LIB_OK']='True'




#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice





class MalwareDetectionModel:
    def __init__(self):
        
        # !!!!!!!!!!!!!!!! pick your model below by comment!!!!!!!!!!!!!!!!!!
        #self.model_string = 'LogisticRegression'
        #self.model_string = 'RandomForestClassifier'
        self.model_string = 'SupportVectorMachine'
        #self.model_string = 'DeepLearning'
         
        # needed for pickling
        from sklearn import model_selection
        from sklearn.linear_model import LogisticRegression
        from sklearn.impute import SimpleImputer
        from sklearn.preprocessing import OneHotEncoder
        from sklearn.preprocessing import LabelEncoder
        from sklearn.impute import SimpleImputer
        import matplotlib.pyplot as plt
        from sklearn.ensemble import RandomForestClassifier
        from sklearn.svm import SVC
        #from keras.models import Sequential
        #from keras.layers import Dense
        
        self.target = 'HasDetections'
        self.attributes_to_keep = ['AVProductsInstalled',
                                        'Census_IsAlwaysOnAlwaysConnectedCapable',
                                        'DefaultBrowsersIdentifier',
                                        'ProductName',
                                        'Platform',
                                        'SkuEdition',
                                        'IsProtected',
                                        'Firewall',
                                        'Wdft_IsGamer',
                                        'Census_OSWUAutoUpdateOptionsName',
                                        'Census_GenuineStateName',
                                        'Census_ActivationChannel',
                                        'Census_ProcessorCoreCount',                               
                                        'Census_TotalPhysicalRAM',                             
                                        'AVProductStatesIdentifier',
                                        'Census_IsVirtualDevice',
                                        'Census_IsTouchEnabled',
                                        'AVProductsEnabled',
                                        'SMode',
                                        'Wdft_RegionIdentifier',
                                        'IsSxsPassiveMode',
                                        'Census_IsPenCapable',
                                        'OsSuite',
                                        'Census_FirmwareManufaturerIdentifier',
                                        'Census_FirmwareVersionIdentifier',
                                        'CityIdentifier',
                                        'UacLuaenable',
                                        'Census_OSBuildRevision',
                                        ]
        
        self.dtypes = {
         'MachineIdentifier':                                    'category',
         'ProductName':                                          'category',
         'EngineVersion':                                        'category',
         'AppVersion':                                           'category',
         'AvSigVersion':                                         'category',
         'IsBeta':                                               'int8',
         'RtpStateBitfield':                                     'float16',
         'IsSxsPassiveMode':                                     'int8',
         'DefaultBrowsersIdentifier':                            'float16',
         'AVProductStatesIdentifier':                            'float32',
         'AVProductsInstalled':                                  'float16',
         'AVProductsEnabled':                                    'float16',
         'HasTpm':                                               'int8',
         'CountryIdentifier':                                    'int16',
         'CityIdentifier':                                       'float32',
         'OrganizationIdentifier':                               'float16',
         'GeoNameIdentifier':                                    'float16',
         'LocaleEnglishNameIdentifier':                          'int8',
         'Platform':                                             'category',
         'Processor':                                            'category',
         'OsVer':                                                'category',
         'OsBuild':                                              'int16',
         'OsSuite':                                              'int16',
         'OsPlatformSubRelease':                                 'category',
         'OsBuildLab':                                           'category',
         'SkuEdition':                                           'category',
         'IsProtected':                                          'float16',
         'AutoSampleOptIn':                                      'int8',
         'PuaMode':                                              'category',
         'SMode':                                                'float16',
         'IeVerIdentifier':                                      'float16',
         'SmartScreen':                                          'category',
         'Firewall':                                             'float16',
         'UacLuaenable':                                         'float32',
         'Census_MDC2FormFactor':                                'category',
         'Census_DeviceFamily':                                  'category',
         'Census_OEMNameIdentifier':                             'float16',
         'Census_OEMModelIdentifier':                            'float32',
         'Census_ProcessorCoreCount':                            'float16',
         'Census_ProcessorManufacturerIdentifier':               'float16',
         'Census_ProcessorModelIdentifier':                      'float16',
         'Census_ProcessorClass':                                'category',
         'Census_PrimaryDiskTotalCapacity':                      'float32',
         'Census_PrimaryDiskTypeName':                           'category',
         'Census_SystemVolumeTotalCapacity':                     'float32',
         'Census_HasOpticalDiskDrive':                           'int8',
         'Census_TotalPhysicalRAM':                              'float32',
         'Census_ChassisTypeName':                               'category',
         'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
         'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
         'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
         'Census_PowerPlatformRoleName':                         'category',
         'Census_InternalBatteryType':                           'category',
         'Census_InternalBatteryNumberOfCharges':                'float32',
         'Census_OSVersion':                                     'category',
         'Census_OSArchitecture':                                'category',
         'Census_OSBranch':                                      'category',
         'Census_OSBuildNumber':                                 'int16',
         'Census_OSBuildRevision':                               'int32',
         'Census_OSEdition':                                     'category',
         'Census_OSSkuName':                                     'category',
         'Census_OSInstallTypeName':                             'category',
         'Census_OSInstallLanguageIdentifier':                   'float16',
         'Census_OSUILocaleIdentifier':                          'int16',
         'Census_OSWUAutoUpdateOptionsName':                     'category',
         'Census_IsPortableOperatingSystem':                     'int8',
         'Census_GenuineStateName':                              'category',
         'Census_ActivationChannel':                             'category',
         'Census_IsFlightingInternal':                           'float16',
         'Census_IsFlightsDisabled':                             'float16',
         'Census_FlightRing':                                    'category',
         'Census_ThresholdOptIn':                                'float16',
         'Census_FirmwareManufacturerIdentifier':                'float16',
         'Census_FirmwareVersionIdentifier':                     'float32',
         'Census_IsSecureBootEnabled':                           'int8',
         'Census_IsWIMBootEnabled':                              'float16',
         'Census_IsVirtualDevice':                               'float16',
         'Census_IsTouchEnabled':                                'int8',
         'Census_IsPenCapable':                                  'int8',
         'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
         'Wdft_IsGamer':                                         'float16',
         'Wdft_RegionIdentifier':                                'float16',
         'HasDetections':                                        'int8'
                }
        
        self.fileName = 'trainfile.csv'
        self.testDataTemp = pd.read_csv(self.fileName, dtype=self.dtypes)
        self.test_size = 0.33
        self.seed = 7
        self.X_train = []
        self.Y_train = self.testDataTemp['HasDetections']
        self.testData = self.testDataTemp.drop(columns=['HasDetections'])
        self.testAttributes = []

        if(self.model_string == 'LogisticRegression'):
            self.model = LogisticRegression(solver='lbfgs', multi_class='auto', max_iter=1000)
        elif (self.model_string == 'RandomForestClassifier'):
            self.model = RandomForestClassifier(n_estimators=100)
        elif (self.model_string == 'SupportVectorMachine'):
            self.model = SVC(kernel='rbf',class_weight='balanced')
        elif (self.model_string == 'DeepLearning'):
            self.model = Sequential()

        
        
        
 
        
        
    #trains a model, you can access the malware_train.csv file for training your model
    def train(self):     
        data, attributes = self.getData(self.testData)
        if(self.model_string == 'LogisticRegression'):
            myModel = self.logistic_regression(data, attributes)
        elif(self.model_string == 'RandomForestClassifier'):
            myModel = self.random_forest(data, attributes)
        elif(self.model_string == 'SupportVectorMachine'):
            myModel = self.support_vector_machine(data, attributes)
        elif(self.model_string == 'DeepLearning'):
            myModel = self.deep_learning(data, attributes)
        
        print('Training Model')
        return myModel
    
    def deep_learning(self, data, attributes):
        
        #needed for pickling
        from sklearn import model_selection
        from sklearn.linear_model import LogisticRegression
        from sklearn.impute import SimpleImputer
        from sklearn.preprocessing import OneHotEncoder
        from sklearn.preprocessing import LabelEncoder
        from sklearn.impute import SimpleImputer
        import matplotlib.pyplot as plt
        from keras.models import Sequential
        from keras.layers import Dense
        from keras.layers import Dropout
        
        data = data.astype('category')
        dummies = pd.get_dummies(data, drop_first=True)
        dummy_attributes = dummies.columns.tolist()
        self.testAttributes = dummy_attributes
        imp_mean = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
        dummies = imp_mean.fit_transform(dummies)
        dummies = pd.DataFrame(dummies)
        dummies.columns = dummy_attributes
        self.X_train = dummies
        
        # create model
        
        self.model.add(Dense(12, input_dim=len(dummy_attributes), activation='relu'))
        self.model.add(Dropout(0.3, noise_shape=None, seed=None))
        self.model.add(Dense(8, activation='relu'))
        self.model.add(Dropout(0.2, noise_shape=None, seed=None))
       
        self.model.add(Dense(6, activation = "relu"))
        self.model.add(Dense(1, activation='sigmoid'))
        self.model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
    
        #self.model.add(Dense(50, activation = "relu", input_shape=(10000, len(dummy_attributes))))
        # Hidden - Layers
        #self.model.add(Dropout(0.3, noise_shape=None, seed=None))
        #self.model.add(Dense(50, activation = "relu")
        #self.model.add(Dropout(0.2, noise_shape=None, seed=None))
        #self.model.add(Dense(50, activation = "relu"))
        # Output- Layer
        #self.model.add(Dense(1, activation = "sigmoid"))model.summary()        
        self.model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
        # Fit the model
        fit = self.model.fit(self.X_train, self.Y_train, epochs=10, batch_size=10)
        return fit
        
    def support_vector_machine(self, data, attributes):
        #needed for pickling
        from sklearn import model_selection
        from sklearn.linear_model import LogisticRegression
        from sklearn.impute import SimpleImputer
        from sklearn.preprocessing import OneHotEncoder
        from sklearn.preprocessing import LabelEncoder
        from sklearn.impute import SimpleImputer
        import matplotlib.pyplot as plt
        from sklearn.svm import SVC
        
        data = data.astype('category')
        dummies = pd.get_dummies(data, drop_first=True)
        dummy_attributes = dummies.columns.tolist()
        self.testAttributes = dummy_attributes
        imp_mean = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
        dummies = imp_mean.fit_transform(dummies)
        dummies = pd.DataFrame(dummies)
        dummies.columns = dummy_attributes
        self.X_train = dummies
          
        fit = self.model.fit(self.X_train, self.Y_train) 
        return fit
    
        
    def random_forest(self, data, attributes):
         # needed for pickling
        print("random forest")
        from sklearn import model_selection
        from sklearn.linear_model import LogisticRegression
        from sklearn.impute import SimpleImputer
        from sklearn.preprocessing import OneHotEncoder
        from sklearn.preprocessing import LabelEncoder
        from sklearn.impute import SimpleImputer
        import matplotlib.pyplot as plt
        from sklearn.ensemble import RandomForestClassifier
        
        data = data.astype('category')
        
        dummies = pd.get_dummies(data, drop_first=True)
        dummy_attributes = dummies.columns.tolist()
        self.testAttributes = dummy_attributes
        imp_mean = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
        dummies = imp_mean.fit_transform(dummies)
        dummies = pd.DataFrame(dummies)
        dummies.columns = dummy_attributes
        self.X_train = dummies
        #dummies = dummies.rename(columns={'HasDetections_1':'HasDetections'})
        #self.export_to_excel(self.X_train)
        
        
        #Create a Gaussian Classifier
        #self.model is RandomForestClassifier(n_estimators=100)
        
        #Train the model using the training sets y_pred=clf.predict(X_test)
        fit = self.model.fit(self.X_train,self.Y_train)
        return fit
        
    def logistic_regression(self, data, attributes):
         # needed for pickling
        from sklearn import model_selection
        from sklearn.linear_model import LogisticRegression
        from sklearn.impute import SimpleImputer
        from sklearn.preprocessing import OneHotEncoder
        from sklearn.preprocessing import LabelEncoder
        from sklearn.impute import SimpleImputer
        import matplotlib.pyplot as plt
        from sklearn.ensemble import RandomForestClassifier
        
        data = data.astype('category')
        
        dummies = pd.get_dummies(data, drop_first=True)
        dummy_attributes = dummies.columns.tolist()
        self.testAttributes = dummy_attributes
        imp_mean = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
        dummies = imp_mean.fit_transform(dummies)
        dummies = pd.DataFrame(dummies)
        dummies.columns = dummy_attributes
        self.X_train = dummies
        #dummies = dummies.rename(columns={'HasDetections_1':'HasDetections'})
        #self.export_to_excel(self.X_train)
        
        
        #Create a Gaussian Classifier
        #self.model is RandomForestClassifier(n_estimators=100)
        
        #Train the model using the training sets y_pred=clf.predict(X_test)
        fit = self.model.fit(self.X_train,self.Y_train)
        return fit
        
    #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
    #This function must return the predicted probabilities for the test machines
    def predict_probablities(self, test_data):
        
        from sklearn import model_selection
        from sklearn.linear_model import LogisticRegression
        from sklearn.impute import SimpleImputer
        from sklearn.preprocessing import OneHotEncoder
        from sklearn.preprocessing import LabelEncoder
        from sklearn.impute import SimpleImputer
        import matplotlib.pyplot as plt
        from sklearn.ensemble import RandomForestClassifier
        from keras.models import Sequential
        from keras.layers import Dense
        from sklearn.svm import SVC
        import numpy as np
        predictions = []
        # next lines are because the vm and code you are using does do allow the data to be read in chunks
        data, attributes = self.getData(test_data)
        #if(self.model_string == 'RandomForestClassifier' or self.model_string =='SupportVectorMachine'): 
        self.export_to_csv(data)
        data_pages = pd.read_csv("output.csv", iterator=True, chunksize=1000)
        for pages in data_pages:
            data = pages.astype('category')
            #print(data)
            dummies = pd.get_dummies(data, drop_first=True)
            #print(dummies)
            dummies = dummies.T.reindex(self.testAttributes).T.fillna(0)
            dummy_attributes = dummies.columns.tolist()
        
            for items in dummy_attributes:
                if items not in self.testAttributes:
                    dummies.drop(items, axis=1, inplace=True)
        
            imp_mean = SimpleImputer(missing_values=np.nan, strategy='most_frequent')
            dummies = imp_mean.fit_transform(dummies)
            dummies = pd.DataFrame(dummies)
            dummies.columns = dummy_attributes
            self.X_test = dummies
            predictions.extend(self.model.predict(self.X_test))
            
       # elif(self.model_string == 'LogisticRegression'):
        #    predictions = self.model.predict(self.X_test)
        
        print('Predicting malware')
   
        return predictions

    
    def getData(self, data): 
        
        # needed for pickling
        from sklearn import model_selection
        from sklearn.linear_model import LogisticRegression
        from sklearn.impute import SimpleImputer
        from sklearn.preprocessing import OneHotEncoder
        from sklearn.preprocessing import LabelEncoder
        from sklearn.impute import SimpleImputer
        import matplotlib.pyplot as plt
        from sklearn.ensemble import RandomForestClassifier
        
        
        attributes = data.columns.tolist()
        for items in attributes:
            if items not in self.attributes_to_keep:
                data.drop(items, axis=1, inplace=True)

        
        return data, attributes
   
   
       
    def correlation_heatmap(self):
        train = pd.read_csv('testfile.csv')
        pd.set_option('display.max_rows', 1000)
        pd.set_option('display.max_columns', 1000)
        pd.set_option('display.width', 150)
        correlations = train.corr()
        #hasDetectionCorrelations = correlations[['HasDetections']].sort_values(by='HasDetections')
        #print(hasDetectionCorrelations)
        fig, ax = plt.subplots(figsize=(50,50))
        sns.heatmap(correlations, vmax=1.0, center=0, fmt='.2f',
        square=True, linewidths=.5, annot=True, cbar_kws={"shrink": .70})
        plt.show();
        
    def correlation_correlation(self, value):
        train = pd.read_csv('testfile.csv')
        pd.set_option('display.max_rows', 1000)
        pd.set_option('display.max_columns', 1000)
        pd.set_option('display.width', 150)
        correlations = train.corr()
        hasDetectionCorrelations = correlations[[value]].sort_values(by=value)
        print(hasDetectionCorrelations)
  
      
    def getDataTypes(self):
        df = pd.read_csv('testfile.csv')
        pd.set_option('display.max_rows', 500)
        pd.set_option('display.max_columns', 500)
        pd.set_option('display.width', 150)
        typelist = []
        for classifications in df:
            value = df[classifications].name
            valueType = df[classifications].dtype
            if valueType == 'object':
                valueType = 'category'
            if valueType == 'int64':
                valueType = 'int'
            if valueType == 'float64':
                valueType = 'float'
                
                #print("\'{0}\': \t\t\t\t\'{1}\' \t\t# not used".format(value, valueType))
                #print('%33s' % value, '%20s' % valueType)
            #typelist.append("\'{0}\': \'category\', # not used".format(value, valueType))
            #print('%10s' % value, '%20s' % valueType)
            typelist.append("\'{0}\': \'{1}\', # not used\n".format(value, valueType))
            print("\'{0:50}\': \'{1}\'".format(value, valueType))
        #print(typelist)
        return typelist
    
    def getCoulmnMajority(self, value):
        train = pd.read_csv('testfile.csv')
        train = train.dropna(subset=[value])
        print('Max total',train[value].value_counts().max())
        print('Min toal' ,train[value].value_counts().min())
        print('Max Value',train[value].value_counts().idxmax())
     
    def find_dupicates(self):
        df = pd.read_csv('testfile.csv')
        pd.set_option('display.max_rows', 500)
        pd.set_option('display.max_columns', 500)
        pd.set_option('display.width', 150)
        print(df.duplicated())
        
    def export_to_excel(self, data):
        data.to_excel("output.xlsx")
        
    def export_to_csv(self, data):
        data.to_csv("output.csv")
       
    def get_f1_scores(self, data):
        from sklearn.metrics import classification_report
        #print(self.testData)
        print(classification_report(self.testDataTemp[self.target], self.model.predict(data)))
        
    def get_columns_skew(self, data):
        print(data.skew(axis = 0, skipna = True))

  

#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    
    detectionModel = MalwareDetectionModel()
    #detectionModel.correlation_heatmap()
    #detectionModel.find_dupicates()
    #detectionModel.getCoulmnMajority('HasDetections')
    #detectionModel.getDataTypes()
    #detectionModel.train()
    #detectionModel.get_f1_scores(detectionModel.X_train)
    #detectionModel.predict_probablities()
    detectionModel.get_columns_skew(detectionModel.testDataTemp)
    #test the file like it is run by malware-auc.py
    '''
    test_with_labels = pd.read_csv("trainfile.csv",dtype=detectionModel.dtypes)
    test = test_with_labels.drop('HasDetections', axis=1)
    predictions = detectionModel.predict_probablities(test)
    print("length" , predictions)
    '''
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
    print("all done")
